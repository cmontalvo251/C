//WORK TASKS

=========================SIMPILOT WORK TASKS===========================

Try and finish these before Friday of this week

1.) Add navio receiver rcin protocols to current RCInput.h/.cpp and test with receiver in the Lab

2.) Add ESC outputs to existing RCOoutput but combine everything to the minimum viable set of routines. 
You'll probably have to create some test scripts

3.) Since you just edited the RCInput and RCOutput routine go back and make
sure that SIMONLY, SIL and Rpi hooks are working. In order to get the RPi
hooks working you're going to have to compile this routine in AUTO mode
on the RPI. You'll also need to hook up the receiver and some servos to make 
sure you're getting the output you think you're supposed to get. 

4.) Quadcopter autopilot - write a simple PID loop. 

5.) Test this on PiQuad and Bumblebee in the lab and video tape it to post on youtube

========================FASTPILOT WORK TASKS====================

Work on these while you're in St. Augustine

1.) Finish the actuator dynamics

2.) Quadcopter aerodynamics. Remember that microsec pulse is the input to this routine (ctlcomms)

========================WOODEN DRONE WORK TASKS=================================

1.) From here I'd like to start editing the sensor routines to include Arduino
hooks. The sensor.h file should work at the moment on both desktop and Rpi so
it's time to get it to work on Arduino hooks. Edit the Sensor routine to use the newly formed folders. Think a bit more on how you want to have this sensor block. I'm assuming you'll just be importing 
all the sensors? Pitot, IMU, GPS, etc??? What if those sensors are not connected?
Is there a way for the controller to ignore erroneous data? Or maybe just turn them
on and off in the controller?

2.) I then would like you to make an INO routine that logs all sensor data 
IMU, MPL, GPS (I think those are all the sensors). I'd like there to be a
SIMONLY version of this as well where the computer just fakes the sensors. 
Might need to call this DESKTOP since that's what all the hooks are

3.) Using this log routine I want you to log like an hour of data to disk just
using Serial.print and then save it for later processing of noise and what
not

4.) Once the Arduino hooks are in I would like one more Arduino Routine
that reads the RCInput and then feeds them (pass through) to RCOutput. This
will require you to use the RCInput and RCOutput routines which hopefully
got combined between Navio and Arduino at which point you'll also need hooks
in there for the JOYSTICK as well. 

5.) Using this routine log back in to betaflight and make sure you have 
everything set up properly for the on board Flight controller. Again remember that the autopilot (non-PID) is the only thing that's going to go on Gitlab so for now you can make a pass through just like
above and make sure the receiver is sending appropriate signals to the servos

6.) You should also be able to fly the drone at this point

7.) At this point you can start analyzing the data you obtained in 3. See
if you can get bias, std dev, noise, etc and then add that to the Sensors
routine when you're using DESKTOP and POLLUTED sensor mode.

8.) Using a scale and the pass through Arduino routine get the thrust of
the motor as a function of microsend pulse and add that to the aerodynamics
routine for the quadcopter

===================================================================

When you get to here take a look at the text below and see where 
you need to go.

0.) Link code to FASTPilot
5.) Aircraft dynamics
6.) X8 dynamics
8.) aircraft autopilot
9.) X8 autopilot

3.) Run SIL on RPI - This mode should probably throw an error in my opinion since you
can't run opengl. 
4.) Run HIL on Desktop and RPI - You need to write two instances of the same software.
The RPI/HIL version will accept a polluted state vector from the computer and run that
through the control algorithm and then pass back the control commands to the integrator.
So serialListens and SerialResponds etc will need to be written to send data back and
forth
5.) AUTO - In this mode the sensors will be called in the loop and the commands will
be compute using the autopilot. These commands will then be sent to the actuators.
6.) How do you feel about updating OpenGL rendering environment to Unreal engine or something like Godot or even Unity???

///Potential Issues in the future

1.) We have an issue with which variables we log to the SD card.
Right now the number of variables is set in the Dynamics.cpp setup routine
but it seems more realistic to have the programmer decide which variables they want
logged to the SD card. As such I wonder if in the init routine for the logger
we compute which states we want logged. I think once we start porting this over
to the Raspberry Pi and running in AUTO mode we will have to start doing a large amount
of overhaul to get this to work.
